//
// 现在我们已经熟悉了多线程的基本原理，
// 让我们大胆尝试一个来自数学的实际例子：
// 计算圆周率 PI，并且要有足够的精度。
//
// 计算 PI 有很多方法，其中一些已经有几百年的历史。
// 对我们来说，这些“古老”的方法反而很适合做练习。
// 因为当时的数学家没有现代计算机，
// 只能用纸和笔来处理这些问题。
// 当然，具体精度取决于我们想要小数点后多少位。
//
// 这些方法至今依然容易理解，
// 至少对我来说是这样。 ;-)
//
// 时间回到大约 1672 年（如果你想了解更多，可以查维基百科）。
// 当时一些数学家重新发现了一种逼近圆周率的方法。
// 其中有苏格兰数学家 Gregory、德国数学家 Leibniz，
// 以及更早的印度数学家 Madhava。
// 他们都独立提出了相同的公式。
// 这个公式最终在 1682 年由 Leibniz 发表在《学者通报》上。
// 因此它后来被称为“莱布尼茨级数”，
// 尽管今天也有人称它为 Gregory 或 Madhava 级数。
//
// 我们不深入推导公式，直接看展开式：
//
//        4     4     4     4     4
//  PI = --- - --- + --- - --- + --- ...
//        1     3     5     7     9
//
// 可以看到，级数从整数 4 开始，
// 然后通过加减越来越小的分数逐步逼近 PI。
// 大多数人只记得 PI ≈ 3.14，
// 但实际计算机里存储的常数精度非常高。
// 而这些常数也都是通过类似方法算出来的。
//
// 那么问题来了：要计算多少项才能得到某个精度？
// 答案是：想要小数点后 8 位，需要 1,000,000,000 项。
// 每多一位，就要再多一个零。
// 即使是很快的计算机，处理这么多项时 CPU 也会发热。
// 不过 8 位已经足够我们演示原理。
//
// 莱布尼茨级数的项之间固定相差 2。
// 如果我们从 n = 1 开始，每次加 2 即可。
// 但注意：这些项是交替加减的。
// 用单个循环可以实现，但不够优雅。
// 更好的方法是让两个 CPU 并行：
// 一个计算正项，另一个计算负项，最后再相加即可。
// 需要记住的是：只算正项或负项时，步长变为 4。
//
// 为了增加学习效果，第一条线程的调用已经给出，
// 你需要补充第二条线程的调用。
// 别担心，很简单的。 :-)
//
const std = @import("std");

pub fn main() !void {
    const count = 1_000_000_000;
    var pi_plus: f64 = 0;
    var pi_minus: f64 = 0;

    {
        // 第一个线程：计算正项。
        const handle1 = try std.Thread.spawn(.{}, thread_pi, .{ &pi_plus, 5, count });
        defer handle1.join();

        // 第二个线程：计算负项。
        const handle2 = try std.Thread.spawn(.{}, thread_pi, .{ &pi_minus, 3, count });
        defer handle2.join();
    }
    // 这里将结果相加。
    std.debug.print("PI ≈ {d:.8}\n", .{4 + pi_plus - pi_minus});
}

fn thread_pi(pi: *f64, begin: u64, end: u64) !void {
    var n: u64 = begin;
    while (n < end) : (n += 4) {
        pi.* += 4 / @as(f64, @floatFromInt(n));
    }
}
// 如果你愿意，可以增加循环次数来提高精度。
//
// 但要注意：
// 如果想真正发挥并行计算的优势，
// 编译时必须加上 `-O ReleaseFast` 参数。
// 否则调试模式下的函数会拖慢速度，
// 让“几秒钟”变成“几分钟”。
//
// 另外，你还需要去掉 `print` 里的格式化限制，
// 否则额外的小数位将不会显示。
