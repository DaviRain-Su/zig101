//
// 多年来，终端已经走了很长一段路。
// 从闪烁的 CRT 显示器上的单色文本行，逐渐发展到今天的现代终端模拟器，
// 支持清晰的图像、真彩色、字体、连字以及所有已知语言的字符。
//
// 将结果格式化得美观，并便于用户快速理解信息，正是用户所期望的。 <3
//
// 多年来，C 语言设定了字符串格式化的标准，Zig 也在追随并不断发展。
// 由于发展迅速，目前还没有关于标准库功能（如字符串格式化）的官方文档。
//
// 因此，了解 Zig 中字符串格式化的唯一权威方式，
// 就是查看 `format()` 函数的注释：
//
//     https://github.com/ziglang/zig/blob/master/lib/std/fmt.zig#L33
//
// Zig 已经有了非常丰富的格式化选项。
// 这些选项可以用在不同的场景里，通常是将数值转换成各种文本表示形式。
// 输出结果既可以直接显示在终端上，也可以保存以便后续使用或写入文件。
// 当有大量数据需要被其他程序处理时，这尤其有用。
//
// 在 Ziglings 里，我们只关心输出到控制台。
// 但由于文件的格式化指令相同，你学到的内容是通用的。
//
// 因为我们在 Ziglings 里写到的是 "debug" 输出，
// 所以答案通常是这样的：
//
//      print("Text {placeholder} another text \n", .{foo});
//
// 在这个例子中，{placeholder} 会被 foo 替换。
// 但其实它也可以加上格式化指令。那是怎么做到的呢？
//
// 这实际上分几个阶段完成。
// 其中一个阶段是解析转义序列。我们见过最多的例子就是 "\n"，表示换行。
// 每当遇到这个指令，输出就会换到新的一行。
// 转义序列也可以连续写，比如 "\n\n" 会产生两次换行。
//
// 顺便提一句，这些转义序列的效果是直接传递给终端程序的。
// 除了把它们翻译成控制码之外，它们与 Zig 本身没有关系。
// Zig 并不知道什么是 "换行"、"制表符" 或 "响铃"。
//
// Zig *自己* 执行的格式化是在大括号里："{placeholder}"。
// 其中的格式化指令决定了对应的值（比如 foo）是如何显示的。
//
// 这就变得很有趣了，因为 `format()` 接受各种各样的格式化指令。
// 它本身几乎就是一门小语言。下面是一个数值的例子：
//
//     print("Catch-0x{x:0>4}.", .{twenty_two});
//
// 这个格式化指令输出一个带前导零的十六进制数：
//
//     Catch-0x0016.
//
// 你也可以像这样把字符串居中对齐：
//
//     print("{s:*^20}\n", .{"Hello!"});
//
// 输出结果：
//
//     *******Hello!*******
//
// 现在让我们试试格式化的应用。
// 我们决定写一个 1~15 的乘法表。
// 我们希望它整齐美观，数字能排成直直的列，比如：
//
//      X |  1   2   3   4   5  ...
//     ---+---+---+---+---+---+
//      1 |  1   2   3   4   5
//
//      2 |  2   4   6   8  10
//
//      3 |  3   6   9  12  15
//
//      4 |  4   8  12  16  20
//
//      5 |  5  10  15  20  25
//
//      ...
//
// 如果没有字符串格式化，这会很麻烦，
// 因为数字的位数从 1 到 3 不等。
// 但有了格式化，这就简单多了。
//
const std = @import("std");
const print = std.debug.print;

pub fn main() !void {
    // 最大乘数
    const size = 15;

    // 打印表头：
    //
    // 先打印一个 'X' 作为对角标识。
    print("\n X |", .{});

    // 表头行，从 1 到 size。
    for (0..size) |n| {
        print("{d:>3} ", .{n + 1});
    }
    print("\n", .{});

    // 打印表头的分隔线。
    var n: u8 = 0;
    while (n <= size) : (n += 1) {
        print("---+", .{});
    }
    print("\n", .{});

    // 接下来是真正的乘法表。
    // （有没有比一个整齐的表格更美的东西？）
    for (0..size) |a| {
        print("{d:>2} |", .{a + 1});

        for (0..size) |b| {
            // 在这里填上合适的格式化，让列对齐。
            print("{???} ", .{(a + 1) * (b + 1)});
        }

        // 每行结束后用两个换行符。
        print("\n\n", .{});
    }
}
