//
// 我们已经看到 Zig 会在编译期隐式执行一些计算。
// 但有时你可能想要 **显式** 地请求在编译期进行计算。
// 为此，我们有一个新关键字：
//
//  .     .   .      o       .          .       *  . .     .
//    .  *  |     .    .            .   .     .   .     * .    .
//        --o--            comptime        *    |      ..    .
//     *    |       *  .        .    .   .    --*--  .     *  .
//  .     .    .    .   . . .      .        .   |   .    .  .
//
// 当放在变量声明前时，`comptime` 能保证这个变量的每一次使用
// 都会在 **编译期** 完成。
//
// 举个简单的例子，对比这两条语句：
//
//    var bar1 = 5;            // 错误！
//    comptime var bar2 = 5;   // 正确！
//
// 第一条语句会报错，因为 Zig 假设用 `var` 声明的可变变量
// 会在运行期使用，而我们并没有给它指定运行期类型（如 u8 或 f32）。
// 尝试在运行期使用一个大小未确定的 comptime_int 属于 **内存犯罪** ——
// 你被捕了！
//
// 第二条语句没问题，因为我们明确告诉 Zig `bar2` 是编译期变量。
// Zig 会帮助我们保证这一点，如果我们弄错了，它会发出提示。
//
const print = @import("std").debug.print;

pub fn main() void {
    //
    // 在这个人为设计的例子中，
    // 我们决定用一个变量 `count` 来分配数组！
    // 但这里少了点什么……
    //
    var count = 0;

    count += 1;
    const a1: [count]u8 = .{'A'} ** count;

    count += 1;
    const a2: [count]u8 = .{'B'} ** count;

    count += 1;
    const a3: [count]u8 = .{'C'} ** count;

    count += 1;
    const a4: [count]u8 = .{'D'} ** count;

    print("{s} {s} {s} {s}\n", .{ a1, a2, a3, a4 });

    // 内建函数加餐！
    //
    // `@compileLog()` 是一个类似于 print 的内建函数，
    // 但它只在 **编译期** 工作。
    // Zig 编译器会把 `@compileLog()` 当作错误处理，
    // 所以它一般用于临时调试编译期逻辑。
    //
    // 试着取消下面这一行的注释并运行，看看效果：
    //@compileLog("编译期 count 的值: ", count);
}
