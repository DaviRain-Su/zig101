//
// Zig 支持 IEEE-754 浮点数，具体有这些大小：f16、f32、f64、f80 和 f128。
// 浮点数字面量的写法和整数类似，但也可以用科学计数法：
//
//     const a1: f32 = 1200;       //    1,200
//     const a2: f32 = 1.2e+3;     //    1,200
//     const b1: f32 = -500_000.0; // -500,000
//     const b2: f32 = -5.0e+5;    // -500,000
//
// 十六进制浮点数不能用字母 `e`，因为那是一个十六进制数字，
// 所以要用 `p`：
//
//     const hex: f16 = 0x2A.F7p+3; // 哇，好晦涩！
//
// 请务必选择足够大的浮点类型来存储你的值（无论是有效位数还是数量级）。
// 四舍五入可能还能接受，但过大或过小的数会变成 inf 或 -inf（正无穷或负无穷）！
//
//     const pi: f16 = 3.1415926535;   // 会被舍入到 3.140625
//     const av: f16 = 6.02214076e+23; // 阿伏伽德罗数 → inf（无穷大）！
//
// 在使用数字字面量进行运算时，请确保类型匹配。Zig 不会偷偷进行不安全的类型强制转换：
//
//    var foo: f16 = 5; // ✅ 没问题
//
//    var foo: u16 = 5; // 这是不同类型的字面量
//    var bar: f16 = foo; // ❌ 错误
//
// 请修复这个程序里的两个浮点问题，并把结果以整数形式显示出来。
//
const print = @import("std").debug.print;

pub fn main() void {
    // 航天飞机在发射时（包括助推器和燃料箱）的近似重量
    // 是 4,480,000 磅。
    //
    // 我们将其从磅转换成公制单位，换算系数是 1 磅 = 0.453592 千克。
    const shuttle_weight: f64 = 0.453592 * 4_480_000.0;

    // 默认情况下，浮点数值会用科学计数法显示。
    // 可以尝试使用 '{d}' 和 '{d:.3}' 来观察十进制格式化效果。
    print("Shuttle liftoff weight: {d:.0} metric tons\n", .{shuttle_weight / 1000.0});
}

// 进一步深入：
//
// 举例来说，Zig 的 f16 是 IEEE 754 的 “半精度” 二进制浮点数格式（binary16），
// 在内存中是这样存储的：
//
//         0 1 0 0 0 0 1 0 0 1 0 0 1 0 0 0
//         | |-------| |-----------------|
//         |   指数         有效数字
//         |
//          符号
//
// 这个例子代表的是十进制数 3.140625，恰好是 f16 能表示的最接近 π 的数。
// 这是因为 IEEE-754 的浮点存储方式：
//
//   * 符号位 0 表示正数。
//   * 指数位 10000 → 16。
//   * 有效数字位 1001001000 → 十进制值 584。
//
// IEEE-754 通过修改这些值来节省空间：
//   * 指数位要减去固定偏移量 01111（这里是 10000 - 01111 = 1，即 2^1）。
//   * 有效数字部分隐含一个前导 1 → 1.1001001000（二进制） = 1.5703125（十进制）。
//
// 于是得到：
//
//     2^1 * 1.5703125 = 3.140625
//
// 你可以立刻忘掉这些实现细节。
// 重要的是：浮点数擅长存储非常大或非常小的值（f64 甚至能表示宇宙中原子数量的规模），
// 但位数可能被舍入，因此结果的精度低于整数。
//
// 趣味知识：有时你会看到有效数字被称作 “尾数（mantissa）”，但 Donald E. Knuth 说不要这样叫。
//
// C 兼容性小知识：Zig 还有一个专门用于 C ABI 的浮点类型，叫 `c_longdouble`。
