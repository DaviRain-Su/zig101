//
// 每当有大量计算时，就会出现一个问题：如何同时执行任务？
// 在练习 84-91 中，我们已经学习过一种方法 —— 异步进程。
//
// 然而，处理器的计算能力只是分配给已启动和正在运行的任务，
// 当需要纯粹的计算能力时，这种方式会达到极限。
//
// 例如，在基于工作量证明 (PoW) 的区块链中，矿工需要为某个字符串找到一个随机数 (nonce)，
// 使得字符串和随机数的哈希值的前 m 位为零。
// 因为最先解决问题的矿工能获得奖励，大家都想尽快完成计算。
//
// 这时，多线程就派上用场了。
// 多线程可以把任务真正分配到 CPU 或 GPU 的多个核心上执行，
// 这就意味着性能的成倍提升。
//
// 下图大致说明了几种不同的进程执行方式。
// “总时间”一栏表示：如果除了同步和异步处理中的单核心外，
// 增加第二个核心帮助完成任务，整体执行时间会怎样变化。
//
// 在理想情况下，多线程执行只需单线程的一半时间。
// 即使与异步处理相比，也要快得多。
//
//
// 同步处理    异步处理             多线程处理
// ┌──────────┐ ┌──────────┐  ┌──────────┐ ┌──────────┐
// │ 线程 1   │ │ 线程 1   │  │ 线程 1   │ │ 线程 2   │
// ├──────────┤ ├──────────┤  ├──────────┤ ├──────────┤    总时间
// └──┼┼┼┼┼───┴─┴──┼┼┼┼┼───┴──┴──┼┼┼┼┼───┴─┴──┼┼┼┼┼───┴──┬───────┬───────┬──
//    │ T │        │ T │         │ T │        │ T │      │       │       │
//    │ a │        │ a │         │ a │        │ a │      │       │       │
//    │ s │        │ s │         │ s │        │ s │      │       │       │
//    │ k │        │ k │         │ k │        │ k │      │       │       │
//    │ 1 │        │ 1 │         │ 1 │        │ 3 │      │       │       │
//      │            │             │            │      5 秒     │       │
// ┌────┘        ┌───┘         ┌───┘        ┌───┘      │     8 秒     │
// │ 阻塞 │      │ T │         │ T │        │ T │      │       │       │
// └────┐│      │ a │         │ a │        │ a │      │       │       │
//      ││      │ s │         │ s │        │ s │      │       │    10 秒
//    ┌─┘│      │ k │         │ k │        │ k │      │       │       │
//    │ T │     │ 2 │         │ 2 │        │ 4 │      ▼       │       │
//    │ a │     └───┘         └───┘        └───┘─────────     │       │
//    │ s │                                                    │       │
//    │ k │                                                    ▼       │
//    │ 2 │                                                            │
//    └───┘                                                            ▼
//
// 图表改编自一篇博客，详细解释了异步处理与多线程的区别：
// https://blog.devgenius.io/multi-threading-vs-asynchronous-programming-what-is-the-difference-3ebfe1179a5
//
// 本练习的主要目的是阐明 Zig 的做法，因此我们尽量保持简单。
// 毕竟多线程本身已经够复杂了。 ;-)
//
const std = @import("std");

pub fn main() !void {
    // 这里是并行处理开始之前的准备工作。
    std.debug.print("Starting work...\n", .{});

    // 大括号非常重要，用来包围启动线程的区域。
    // 如果没有这些大括号，程序不会等待线程结束，
    // 它们会在程序退出后继续运行。
    {
        // 启动第一个线程，参数为数字
        const handle = try std.Thread.spawn(.{}, thread_function, .{1});

        // 等待线程完成，
        // 然后释放 spawn() 创建的资源。
        defer handle.join();

        // 第二个线程
        const handle2 = try std.Thread.spawn(.{}, thread_function, .{-4}); // 这不太对吧？
        defer handle2.join();

        // 第三个线程
        const handle3 = try std.Thread.spawn(.{}, thread_function, .{3});
        defer ??? // <-- 这里缺点什么

        // 在线程启动后，它们会并行运行，
        // 同时我们还可以在中间做一些别的事情。
        std.Thread.sleep(1500 * std.time.ns_per_ms);
        std.debug.print("Some weird stuff, after starting the threads.\n", .{});
    }
    // 退出大括号后，如果线程还没结束，程序会等待线程执行完毕。
    std.debug.print("Zig is cool!\n", .{});
}

// 每个线程都会执行这个函数。
// 在本例中，我们传入线程编号作为参数。
fn thread_function(num: usize) !void {
    std.Thread.sleep(200 * num * std.time.ns_per_ms);
    std.debug.print("thread {d}: {s}\n", .{ num, "started." });

    // 这个计时器用来模拟线程的工作。
    const work_time = 3 * ((5 - num % 3) - 2);
    std.Thread.sleep(work_time * std.time.ns_per_s);

    std.debug.print("thread {d}: {s}\n", .{ num, "finished." });
}
// 这是最简单的并行运行线程的方法。
// 但在一般情况下，需要更多的管理工作，
// 例如建立线程池，并让线程通过信号量相互通信。
//
// 不过，那是另一个练习的主题了。
