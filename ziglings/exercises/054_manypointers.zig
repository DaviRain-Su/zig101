//
// 你也可以在不使用切片的情况下创建指向多个元素的指针。
//
//     var foo: [4]u8 = [4]u8{ 1, 2, 3, 4 };
//     var foo_slice: []u8 = foo[0..];
//     var foo_ptr: [*]u8 = &foo;
//     var foo_slice_from_ptr: []u8 = foo_ptr[0..4];
//
// foo_slice 和 foo_ptr 的区别在于切片有已知的长度，而指针没有。
// 由你自己来保证 foo_ptr 指向多少个 u8！
//
const std = @import("std");

pub fn main() void {
    // 注意这里我们把 zen12 字符串强制转换成的数组类型
    // （字符串的真正本质会在学习更多特性时揭晓）：
    const zen12: *const [21]u8 = "Memory is a resource.";
    //
    //   当然，也可以把它强制转换为切片：
    //         const zen12: []const u8 = "...";
    //
    // 现在我们把它转成“多元素指针”：
    const zen_manyptr: [*]const u8 = zen12;

    // 你可以像操作数组或切片一样使用 zen_manyptr，
    // 只要你自己记住长度是多少！
    //
    // 在 Zig 里，“字符串”其实就是指向 const u8 数组的指针
    // （或者是 const u8 的切片，就像我们之前看到的那样）。
    // 所以我们也可以把 const u8 的“多元素指针”当作字符串使用，
    // 只要能把它转换为切片。（提示：我们确实知道长度！）
    //
    // 请修复这一行，让下面的 print 能正确打印：
    const zen12_string: []const u8 = zen_manyptr;

    // 真相时刻！
    std.debug.print("{s}\n", .{zen12_string});
}
//
// 这些指针类型是不是已经开始让人头晕了？
//
//     免费的 ZIG 指针速查表！（这里用 u8 作为示例类型。）
//   +---------------+----------------------------------------------+
//   |  u8           |  单个 u8                                     |
//   |  *u8          |  指向单个 u8 的指针                          |
//   |  [2]u8        |  两个 u8                                     |
//   |  [*]u8        |  指向未知数量 u8 的指针                      |
//   |  [*]const u8  |  指向未知数量不可变 u8 的指针                |
//   |  *[2]u8       |  指向一个由 2 个 u8 组成的数组的指针         |
//   |  *const [2]u8 |  指向一个不可变的由 2 个 u8 组成的数组的指针 |
//   |  []u8         |  u8 的切片                                   |
//   |  []const u8   |  不可变 u8 的切片                            |
//   +---------------+----------------------------------------------+
