//
// 位操作在 Zig 中同样是一种非常强大的工具。
// 自计算机时代开始，就有许多算法仅通过移动、设置或逻辑组合位来解决任务。
//
// Zig 在标准库中也会直接使用位操作来实现某些函数，只要有可能。
// 而且只要涉及整数运算，通常就有可能使用位操作。
//
// 乍一看，当内存区域里的“数字”只是发生了变化时，
// 很难理解这些算法到底做了什么。
// 但是不能忘记的是：数字只是位序列的一种解释方式。
//
// 这其实和我们平时相反：我们平时是用位序列来表示数字。
//
// 回顾：1 字节 = 8 位 = 11111111（二进制）= 255（十进制）= FF（十六进制）。
//
// Zig 提供了所有必要的运算符来修改变量内部的位。
// 需要区分修改位时是否会导致溢出。
// 具体细节在 Zig 文档的 **运算符表** 部分。
//
// 下面是一些修改变量位的示例：
//
//          const numOne: u8 = 15;        //   =  0000 1111
//          const numTwo: u8 = 245;       //   =  1111 0101
//
//          const res1 = numOne >> 4;     //   =  0000 0000 - 右移
//          const res2 = numOne << 4;     //   =  1111 0000 - 左移
//          const res3 = numOne & numTwo; //   =  0000 0101 - 与
//          const res4 = numOne | numTwo; //   =  1111 1111 - 或
//          const res5 = numOne ^ numTwo; //   =  1111 1010 - 异或
//
//
// 为了熟悉位操作，我们从一个简单但经常被低估的函数开始，
// 然后再逐步添加其他练习。
//
// 以下内容节选自维基百科。
//
// **交换 (Swap)**
// 在计算机编程中，交换两个变量的操作是指互相交换它们的值。
// 通常，这是在内存中完成的。
// 例如，程序中可能这样定义两个变量（伪代码）：
//
//                        data_item x := 1
//                        data_item y := 0
//
//                        swap (x, y);
//
// 执行 `swap()` 后，x 将包含值 0，而 y 将包含值 1；它们的值被交换。
// 最简单、最常用的方法是使用第三个临时变量：
//
//                        define swap (x, y)
//                        temp := x
//                        x := y
//                        y := temp
//
// 然而，对于整数，我们也可以仅通过位操作实现交换。
// 为此，只需对两个变量做异或操作，结果是一样的。

const std = @import("std");
const print = std.debug.print;

pub fn main() !void {

    // 使用二进制 1101 和 1011 作为 x 和 y 的值
    var x: u8 = 0b1101;
    var y: u8 = 0b1011;

    // 现在通过异或运算来交换这两个变量的值
    x ^= y;
    y ^= x;
    x ^= y;

    print("x = {b}; y = {b}\n", .{ x, y });
}

// 这种变量交换方式利用了异或的特性：
// 两个值的异或结果中包含了这两个值的信息。
// 这种方式曾经（现在有时也）用于加密。
// 公式：值 XOR 密钥 = 密文  =>  密文 XOR 密钥 = 值。
// 由于这种交换是对称的，你也可以用它来交换两个变量。
//
// 当然，用于加密并不理想，但在排序算法（比如冒泡排序）中，
// 这种方法非常好用。
