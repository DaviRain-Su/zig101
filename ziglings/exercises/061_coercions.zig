//
// 学习 Zig 的类型强制规则只需要一点点时间，因为它们非常合乎逻辑。
//
// 1. 类型总是可以被变得「更严格」。
//
//    var foo: u8 = 5;
//    var p1: *u8 = &foo;
//    var p2: *const u8 = p1; // 可变 → 不可变
//
// 2. 数值类型可以强制转换为「更大」的类型。
//
//    var n1: u8 = 5;
//    var n2: u16 = n1; // 整数“拓宽”
//
//    var n3: f16 = 42.0;
//    var n4: f32 = n3; // 浮点“拓宽”
//
// 3. 指向数组的单元素指针可以强制转换为切片或多元素指针。
//
//    const arr: [3]u8 = [3]u8{5, 6, 7};
//    const s: []const u8 = &arr;  // 转成切片
//    const p: [*]const u8 = &arr; // 转成多元素指针
//
// 4. 可变的单元素指针可以强制转换为指向长度为 1 的数组的单元素指针。（很有趣！）
//
//    var five: u8 = 5;
//    var a_five: *[1]u8 = &five;
//
// 5. 有效载荷类型和值 null 可以强制转换为可选类型。
//
//    var num: u8 = 5;
//    var maybe_num: ?u8 = num; // 有效载荷
//    maybe_num = null;         // null
//
// 6. 有效载荷类型和错误可以强制转换为错误联合类型。
//
//    const MyError = error{Argh};
//    var char: u8 = 'x';
//    var char_or_die: MyError!u8 = char; // 有效载荷
//    char_or_die = MyError.Argh;         // 错误
//
// 7. 'undefined' 可以强制转换为任何类型（否则它就没法用了！）
//
// 8. 编译期数字会强制转换为兼容的类型。
//
//    事实上几乎每一个练习程序都有这样的例子，
//    不过关于它的完整解释会在即将到来的“第三只眼启示”主题 comptime 中出现。
//
// 9. 带标签的联合体可以强制转换为当前的标签枚举。
//
// 10. 当带标签联合体的某个标签字段是零长度且只有一个值的类型（例如 void），
//     枚举就可以强制转换为这个带标签的联合体。
//
// 11. 零比特类型（例如 void）可以被强制转换为单元素指针。
//
// 最后三条比较偏门，但你完全可以去读 Zig 的官方文档，
// 并且写一些自己的实验来玩一玩。
//

const print = @import("std").debug.print;

pub fn main() void {
    var letter: u8 = 'A';

    const my_letter:   ???   = &letter;
    //               ^^^^^^^
    //           在这里写下你的类型。
    // 必须能从 &letter（类型是 *u8）强制转换过来。
    // 提示：使用规则 4 和 5。

    // 当你写对了，这里就能正常运行：
    print("Letter: {u}\n", .{my_letter.?.*[0]});
}
