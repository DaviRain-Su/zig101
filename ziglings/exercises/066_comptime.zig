//
// “编译期”（compile time）指的是程序正在被编译时的环境。
// 与之相对的，“运行期”（run time）指的是编译好的程序在执行时的环境
// （通常是作为机器码在硬件 CPU 上运行）。
//
// 错误是一个很容易理解的例子：
//
// 1. 编译期错误：由编译器捕获，通常会给程序员显示一条错误信息。
//
// 2. 运行期错误：要么被正在运行的程序本身捕获，
//    要么被主机硬件或操作系统捕获。
//    可能会被优雅地处理，也可能会导致计算机崩溃
//    （或者直接停机，甚至“冒烟”！）
//
// 所有编译型语言在编译期都必须执行一定的逻辑：
// 分析代码、维护符号表（如变量和函数名）等。
//
// 优化型编译器还能计算出程序中哪些部分可以在编译期预先计算，
// 或者“内联”以提高效率。
// 更聪明的编译器甚至能“展开”循环，把循环逻辑转成线性的语句序列，
// 从而加快执行速度（代价通常只是生成的重复代码体积略大）。
//
// Zig 更进一步，把这些优化作为语言本身不可分割的一部分！
//
const print = @import("std").debug.print;

pub fn main() void {
    // 在 Zig 中，**所有的数字字面量**默认都是 comptime_int 或 comptime_float。
    // 它们是任意大小的（想要多大或多小都可以）。
    //
    // 注意，当我们用 "const" 不可变地赋值时，
    // 不需要指定大小类型（如 "u8"、"i32"、"f64"）。
    //
    // 当我们在程序中使用这些标识符时，
    // 它们的 **值** 会在编译期被直接插入到可执行文件里。
    // 而标识符本身（"const_int" 和 "const_float"）
    // 在编译后的应用程序中是不存在的！
    const const_int = 12345;
    const const_float = 987.654;

    print("不可变: {}, {d:.3}; ", .{ const_int, const_float });

    // 但是当我们把完全相同的值赋给 "var" 可变变量时，情况就不同了。
    //
    // 字面量依然是 comptime_int 和 comptime_float，
    // 但我们希望把它们赋给 **运行期可变** 的标识符。
    //
    // 运行期可变的变量必须对应一块内存区域。
    // 而要分配内存，Zig 必须知道确切需要多少字节。
    // 因此我们需要指定具体的数值类型大小（例如 32 位）。
    // comptime 数字会被强制转换（如果能放下的话！）成你选择的运行期类型。
    var var_int = 12345;
    var var_float = 987.654;

    // 在运行时，我们可以改变这些内存区域里的值。
    var_int = 54321;
    var_float = 456.789;

    print("可变: {}, {d:.3}; ", .{ var_int, var_float });

    // 额外收获：既然我们已经熟悉了 Zig 的内建函数，
    // 就可以直接检查这些变量的实际类型，不用猜了！
    print("类型: {}, {}, {}, {}\n", .{
        @TypeOf(const_int),
        @TypeOf(const_float),
        @TypeOf(var_int),
        @TypeOf(var_float),
    });
}
