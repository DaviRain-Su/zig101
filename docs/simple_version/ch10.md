# Zig 错误处理与联合类型

## 错误的本质

在 Zig 中，错误是**值**，不是异常。关键特性：
- 不能被忽略或丢弃
- 必须显式处理
- 编译器强制检查

```zig
const dir = std.fs.cwd();
_ = dir.openFile("not_exist.txt", .{});  // ❌ 编译错误：不能丢弃错误
```

## 函数返回错误

### 基本语法
```zig
// 可能返回任意错误
fn mayFail() !void {
    try stdout.print("Hello", .{});
}

// 指定具体错误类型
fn readData() ReadError![]u8 {
    // 只能返回 ReadError 或有效值
}
```

### 错误集
错误集是错误值的联合：

```zig
// 定义错误集
const FileError = error{
    FileNotFound,
    PermissionDenied,
    OutOfMemory,
};

// 在函数中使用
fn openConfig() FileError![]u8 {
    // 函数体
}

// 内联错误集
fn process() error{
    InvalidInput,
    Timeout,
}!void {
    // 函数体
}
```

### 错误转换
如果错误集 A 是 B 的超集，可以将 B 的错误转换为 A：

```zig
const AllErrors = error{ OutOfMemory, InvalidToken, Timeout };
const MemoryError = error{ OutOfMemory };

fn cast(err: MemoryError) AllErrors {
    return err;  // 自动转换
}
```

## 错误处理策略

### 1. try - 传播错误
```zig
fn process() !void {
    // 如果 openFile 返回错误，立即返回该错误
    const file = try dir.openFile("data.txt", .{});
    // 继续执行...
}
```

### 2. catch - 处理或提供默认值

**处理错误：**
```zig
const file = dir.openFile("data.txt", .{}) catch |err| {
    logger.log_error(err);
    return err;  // 或返回其他值
};
```

**提供默认值：**
```zig
const number = std.fmt.parseU64(str, 10) catch 0;  // 解析失败返回 0
```

### 3. if 语句
```zig
if (parseU64(str, 10)) |number| {
    // 成功：使用 number
} else |err| {
    // 失败：处理错误
}

// 配合 switch 处理多种错误
if (doOperation()) |result| {
    use(result);
} else |err| switch (err) {
    error.InvalidInput => handleInvalid(),
    error.Timeout => retry(),
    else => return err,
}
```

### 4. errdefer - 错误时清理
```zig
fn createUser(allocator: Allocator) !User {
    const user = try allocator.create(User);
    errdefer allocator.destroy(user);  // 仅在错误时执行

    try database.register(user);  // 如果失败，自动清理
    return user;
}
```

**defer vs errdefer：**
| 关键字 | 执行时机 | 用途 |
|--------|---------|------|
| `defer` | 总是在作用域结束时 | 常规清理 |
| `errdefer` | 仅在发生错误时 | 错误清理 |

## 联合类型

联合类型允许对象是多种类型之一：

### 基本联合
```zig
const DataSource = union {
    file: FileHandle,
    network: Socket,
    memory: []u8,
};

// 使用：一次只能激活一个成员
var source = DataSource{ .file = openFile() };
// source.network = ...  // ❌ 错误：file 成员已激活

// 切换激活成员
source = DataSource{ .network = connectSocket() };
```

### 标记联合
添加 `(enum)` 使联合可用于 switch：

```zig
const Response = union(enum) {
    ok: []u8,
    err: ErrorCode,
    redirect: []const u8,
};

fn handle(response: Response) void {
    switch (response) {
        .ok => |data| process(data),
        .err => |code| logError(code),
        .redirect => |url| redirect(url),
    }
}
```

## 错误处理最佳实践

### 完整示例
```zig
const ResourceError = error{
    OutOfMemory,
    ConnectionFailed,
    InvalidData,
};

fn fetchResource(allocator: Allocator) ResourceError![]u8 {
    // 分配内存，失败时清理
    const buffer = allocator.alloc(u8, 1024) catch {
        return error.OutOfMemory;
    };
    errdefer allocator.free(buffer);

    // 连接并获取数据
    const conn = connect() catch {
        return error.ConnectionFailed;
    };
    defer conn.close();

    // 读取数据
    const len = conn.read(buffer) catch {
        return error.InvalidData;
    };

    return buffer[0..len];
}

// 使用
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    // 方式1：try
    const data1 = try fetchResource(allocator);
    defer allocator.free(data1);

    // 方式2：catch 默认值
    const data2 = fetchResource(allocator) catch &[_]u8{};

    // 方式3：if 处理
    if (fetchResource(allocator)) |data| {
        defer allocator.free(data);
        process(data);
    } else |err| {
        std.log.err("Failed: {}", .{err});
    }
}
```

## 关键要点

1. **错误是值**：必须显式处理，不能忽略
2. **四种处理方式**：`try`（传播）、`catch`（处理）、`if`（分支）、`errdefer`（清理）
3. **错误集**：将相关错误组合，可在函数签名中指定
4. **联合类型**：一次只能有一个活动成员
5. **标记联合**：添加 `(enum)` 可用于 switch
6. **最佳实践**：使用 `errdefer` 确保错误时的资源清理
