# Zig 线程和并行性

## 线程基础

**线程**：独立的执行上下文，用于实现并行计算。Zig 通过 `std.Thread` 提供 POSIX 风格的线程支持。

**线程 vs 进程**：
- 一个进程可包含多个线程（一对多关系）
- 线程共享：堆内存、全局数据、标准文件描述符（stdout/stdin/stderr）
- 线程独有：各自的栈帧（局部变量）

## 创建线程

使用 `Thread.spawn()` 创建线程，需要三个参数：

```zig
const std = @import("std");
const Thread = std.Thread;

fn do_some_work() !void {
    // 线程任务
    Thread.sleep(1000 * std.time.ns_per_ms);
}

pub fn main() !void {
    // spawn(配置, 函数, 参数)
    const thread = try Thread.spawn(.{}, do_some_work, .{});
    thread.join();  // 必须调用 join() 或 detach()
}
```

带参数的线程：
```zig
fn print_id(id: *const u8) !void {
    std.debug.print("Thread ID: {d}\n", .{id.*});
}

pub fn main() !void {
    const id: u8 = 1;
    const thread = try Thread.spawn(.{}, print_id, .{&id});
    thread.join();
}
```

## Join vs Detach

每个线程必须调用其中之一：

### Join（加入）
主线程等待子线程完成：
```zig
thread.join();  // 阻塞等待线程完成
```

### Detach（分离）
线程独立运行，自行释放资源：
```zig
thread.detach();  // 线程独立运行
```

⚠️ **重要**：不调用 `join()` 或 `detach()` 会导致资源泄漏（僵尸线程）。

## 线程池

预创建的线程组，避免频繁创建/销毁线程的开销：

```zig
const Pool = std.Thread.Pool;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    var pool: Pool = undefined;
    try pool.init(.{
        .n_jobs = 4,
        .allocator = allocator,
    });
    defer pool.deinit();

    // 分配任务（函数不能返回错误）
    try pool.spawn(work_function, .{&data});
}
```

## 互斥锁（Mutex）

防止数据竞争，保护临界区：

```zig
const Mutex = std.Thread.Mutex;
var counter: usize = 0;
var mutex: Mutex = .{};

fn increment() void {
    for (0..100000) |_| {
        mutex.lock();      // 进入临界区
        counter += 1;      // 临界区代码
        mutex.unlock();    // 离开临界区
    }
}
```

### 数据竞争问题
当多个线程同时读写共享数据时发生：

```zig
// ❌ 错误：数据竞争
var counter: usize = 0;
fn bad_increment() void {
    for (0..100000) |_| {
        counter += 1;  // 非原子操作，会导致竞态条件
    }
}
```

## 读写锁（RwLock）

允许多个读者同时访问，但写操作独占：

```zig
const RwLock = std.Thread.RwLock;
var lock: RwLock = .{};
var data: u32 = 0;

fn reader() void {
    lock.lockShared();      // 共享锁（读锁）
    const value = data;     // 读取操作
    lock.unlockShared();
}

fn writer() void {
    lock.lock();           // 独占锁（写锁）
    data += 1;             // 写入操作
    lock.unlock();
}
```

## 原子操作

线程安全的单一操作：

```zig
var running = std.atomic.Value(bool).init(true);

fn work() void {
    while (running.load(.monotonic)) {
        // 工作
        if (should_stop) {
            running.store(false, .monotonic);
        }
    }
}
```

## 常见问题

### 死锁
多个线程相互等待对方释放资源：

```zig
// ❌ 死锁示例
fn work1() void {
    mut1.lock();
    Thread.sleep(1 * std.time.ns_per_s);
    mut2.lock();  // 线程2持有mut2，等待mut1
    // ...
}

fn work2() void {
    mut2.lock();
    Thread.sleep(1 * std.time.ns_per_s);
    mut1.lock();  // 线程1持有mut1，等待mut2
    // ...
}
```

**解决方案**：始终以相同顺序获取锁。

### 线程取消
Zig 不支持强制终止线程，使用控制流实现：

```zig
var should_stop = std.atomic.Value(bool).init(false);

fn cancelable_work() void {
    while (!should_stop.load(.monotonic)) {
        // 执行工作
        if (cancel_condition) {
            should_stop.store(true, .monotonic);
            break;
        }
    }
}
```

### Yield（让出）
临时降低线程优先级（主要用于调试）：

```zig
thread.yield();
```

## 最佳实践

1. **总是调用** `join()` 或 `detach()`
2. **保护共享数据**：使用互斥锁或原子操作
3. **避免死锁**：按固定顺序获取多个锁
4. **线程池**：用于频繁的短期任务
5. **读写锁**：读多写少的场景
6. **原子操作**：简单的标志和计数器

## 完整示例

```zig
const std = @import("std");
const Thread = std.Thread;
const Mutex = std.Thread.Mutex;

var mutex: Mutex = .{};
var shared_data: u32 = 0;

fn worker(id: u8) void {
    for (0..5) |_| {
        mutex.lock();
        defer mutex.unlock();

        shared_data += 1;
        std.debug.print("Thread {d}: data = {d}\n", .{id, shared_data});

        Thread.sleep(100 * std.time.ns_per_ms);
    }
}

pub fn main() !void {
    const t1 = try Thread.spawn(.{}, worker, .{1});
    const t2 = try Thread.spawn(.{}, worker, .{2});

    t1.join();
    t2.join();

    std.debug.print("Final: {d}\n", .{shared_data});
}
```
