# Zig Comptime 与泛型编程

## Comptime 关键字

`comptime` 让代码在编译时执行，是 Zig 泛型编程的基础。

### 三种用法

#### 1. 函数参数
强制参数值必须编译时已知：
```zig
fn twice(comptime num: u32) u32 {
    return num * 2;
}

// ✅ 正确：5678 编译时已知
_ = twice(5678);

// ❌ 错误：运行时值
const user_input = try stdin.readInt();
_ = twice(user_input);  // 编译错误
```

#### 2. 表达式
强制表达式编译时执行：
```zig
fn fibonacci(n: u32) u32 {
    if (n < 2) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

test {
    // 运行时执行
    const runtime_result = fibonacci(7);

    // 编译时执行
    const comptime_result = comptime fibonacci(7);
}
```

#### 3. 代码块
整个块在编译时执行：
```zig
const x = comptime blk: {
    var sum: u32 = 0;
    for (0..10) |i| {
        sum += i;
    }
    break :blk sum;  // x = 45，编译时计算
};
```

## 泛型编程

### 泛型函数
使用 `comptime` 参数接收类型：
```zig
fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}

// 使用
const n1 = max(u8, 10, 20);     // T = u8
const n2 = max(f64, 1.5, 2.5);  // T = f64
```

### 泛型数据结构
通过函数返回结构定义：
```zig
fn Stack(comptime T: type) type {
    return struct {
        items: []T,
        capacity: usize,
        length: usize,
        allocator: Allocator,

        const Self = @This();

        pub fn init(allocator: Allocator, capacity: usize) !Self {
            return .{
                .items = try allocator.alloc(T, capacity),
                .capacity = capacity,
                .length = 0,
                .allocator = allocator,
            };
        }

        pub fn push(self: *Self, val: T) !void {
            // 扩容逻辑
            if (self.length + 1 > self.capacity) {
                const new_buf = try self.allocator.alloc(T, self.capacity * 2);
                @memcpy(new_buf[0..self.capacity], self.items);
                self.allocator.free(self.items);
                self.items = new_buf;
                self.capacity *= 2;
            }

            self.items[self.length] = val;
            self.length += 1;
        }

        pub fn pop(self: *Self) void {
            if (self.length == 0) return;
            self.items[self.length - 1] = undefined;
            self.length -= 1;
        }

        pub fn deinit(self: *Self) void {
            self.allocator.free(self.items);
        }
    };
}
```

## 使用泛型栈

```zig
// 创建不同类型的栈
const StackU8 = Stack(u8);
const StackString = Stack([]const u8);
const StackUser = Stack(User);

// 使用示例
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const allocator = gpa.allocator();

var stack = try StackU8.init(allocator, 10);
defer stack.deinit();

try stack.push(1);
try stack.push(2);
try stack.push(3);

stack.pop();  // 移除 3
std.debug.print("Length: {d}\n", .{stack.length});  // 2
```

## 关键要点

### Comptime 核心概念
1. **编译时执行**：`comptime` 强制代码在编译期运行
2. **类型参数**：`type` 关键字表示"类型的类型"
3. **编译时已知**：所有类型都是编译时已知的

### 泛型模式
```zig
// 标准模式：函数返回类型
fn Generic(comptime T: type) type {
    return struct {
        data: T,
        // 结构定义...
    };
}

// 使用
const MyType = Generic(u32);
var instance = MyType{ .data = 42 };
```

### @This() 用法
在结构体内部引用自身类型：
```zig
const Self = @This();  // 获取当前结构体类型
```

### 内存操作
```zig
@memcpy(dest, src);  // 复制内存块
```

## 实践建议

1. **泛型命名**：泛型函数通常大写开头（如 `ArrayList`、`HashMap`）
2. **类型参数**：惯例使用 `T` 作为类型参数名
3. **Self 别名**：在结构内使用 `const Self = @This()` 简化自引用
4. **编译时验证**：利用 `comptime` 进行编译时断言和验证

## 标准库示例

Zig 标准库所有容器都使用相同模式：
```zig
// ArrayList
const list = std.ArrayList(u32).init(allocator);

// HashMap
const map = std.AutoHashMap(u32, []const u8).init(allocator);

// 都是通过泛型函数创建的类型
```
