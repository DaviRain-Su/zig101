# Zig 数据结构

## 动态数组 (ArrayList)

动态数组是可自动增长容量的数组。Zig 提供 `std.ArrayList`。

### 核心概念
- **容量**：数组可容纳的总元素数
- **长度**：当前使用的元素数
- 当长度等于容量时，自动扩展

### 基本用法
```zig
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const allocator = gpa.allocator();

// 创建（推荐指定初始容量）
var list = try std.ArrayList(u8).initCapacity(allocator, 100);
defer list.deinit();

// 添加元素
try list.append('A');
try list.appendSlice("Hello");

// 删除元素
const last = list.pop();           // 删除并返回最后一个
_ = list.orderedRemove(3);         // 删除索引3，保持顺序
_ = list.swapRemove(3);           // 删除索引3，不保持顺序

// 插入元素
try list.insert(2, 'X');          // 在索引2插入
try list.insertSlice(2, "ABC");   // 在索引2插入切片

// 访问
list.items      // 获取底层切片
list.items.len  // 当前长度
list.capacity   // 当前容量
```

## 哈希表 (HashMap)

哈希表是基于键值对的数据结构。

### HashMap 类型对比

| 类型 | 特点 | 使用场景 |
|------|------|----------|
| `AutoHashMap` | 通用，快速 | 一般用途 |
| `AutoArrayHashMap` | 保持插入顺序，遍历快 | 需要频繁遍历 |
| `StringHashMap` | 字符串作为键 | 字符串键场景 |
| `StringArrayHashMap` | 字符串键 + 保持顺序 | 字符串键且需要遍历 |

### 基本用法
```zig
// 通用哈希表
var map = std.AutoHashMap(u32, u8).init(allocator);
defer map.deinit();

// 操作
try map.put(100, 42);              // 插入/更新
const value = map.get(100);        // 获取（返回可选值）
_ = map.remove(100);                // 删除（返回bool）
const count = map.count();         // 元素个数

// 遍历
var it = map.iterator();
while (it.next()) |entry| {
    const key = entry.key_ptr.*;
    const val = entry.value_ptr.*;
}

// 字符串键哈希表
var str_map = std.StringHashMap(u8).init(allocator);
defer str_map.deinit();
try str_map.put("name", 25);

// ArrayHashMap（保持插入顺序）
var arr_map = std.AutoArrayHashMap(u32, u8).init(allocator);
defer arr_map.deinit();
_ = arr_map.swapRemove(key);       // 删除，不保持顺序
_ = arr_map.orderedRemove(key);    // 删除，保持顺序
```

## 链表

### 单链表
```zig
// 1. 定义节点类型
const NodeU32 = struct {
    data: u32,
    node: std.SinglyLinkedList.Node = .{},
};

// 2. 创建链表和节点
var list: std.SinglyLinkedList = .{};
var one = NodeU32{ .data = 1 };
var two = NodeU32{ .data = 2 };

// 3. 插入节点
list.prepend(&one.node);           // 插入到开头
one.node.insertAfter(&two.node);   // 在one后插入two

// 4. 遍历
var it = list.first;
while (it) |node| : (it = node.next) {
    const item: *NodeU32 = @fieldParentPtr("node", node);
    std.debug.print("{}", .{item.data});
}

// 其他操作
_ = list.popFirst();                // 删除第一个
list.remove(&two.node);            // 删除特定节点
const len = list.len();            // 获取长度
```

### 双链表
```zig
// 节点类型
const NodeU32 = struct {
    data: u32,
    node: std.DoublyLinkedList.Node = .{},
};

var list: std.DoublyLinkedList = .{};
var one = NodeU32{ .data = 1 };

// 操作
list.append(&one.node);             // 追加到末尾
list.prepend(&one.node);            // 插入到开头
list.insertAfter(&one.node, &two.node);  // 在指定节点后插入
list.insertBefore(&one.node, &two.node); // 在指定节点前插入
_ = list.pop();                     // 删除最后一个
_ = list.popFirst();                // 删除第一个
```

## 多数组结构 (MultiArrayList)

为结构体的每个字段创建独立的动态数组。

```zig
const Person = struct {
    name: []const u8,
    age: u8,
    height: f32,
};

// 创建多数组
var people = std.MultiArrayList(Person){};
defer people.deinit(allocator);

// 添加数据
try people.append(allocator, .{
    .name = "Alice",
    .age = 25,
    .height = 1.65
});

// 访问特定字段的数组
for (people.items(.age)) |age| {
    std.debug.print("Age: {}\n", .{age});
}

// 使用切片（多次访问时性能更好）
const slice = people.slice();
for (slice.items(.name), slice.items(.age)) |name, age| {
    std.debug.print("{s}: {d}\n", .{name, age});
}
```

## 选择指南

| 需求 | 推荐结构 |
|------|----------|
| 可变大小的序列 | `ArrayList` |
| 键值对存储 | `AutoHashMap` |
| 字符串键 | `StringHashMap` |
| 需要保持插入顺序的映射 | `AutoArrayHashMap` |
| 频繁插入/删除 | 链表 |
| 结构体字段分离存储 | `MultiArrayList` |

## 性能考虑

1. **ArrayList**：优先使用 `initCapacity` 避免频繁重分配
2. **HashMap**：`AutoHashMap` 查找快，`ArrayHashMap` 遍历快
3. **链表**：插入/删除 O(1)，但遍历慢于数组
4. **MultiArrayList**：适合需要分别访问结构体字段的场景

## 通用模式

```zig
// 所有容器都需要：
// 1. 分配器
var container = ContainerType.init(allocator);
// 2. 清理
defer container.deinit();
// 3. 错误处理（可能的分配失败）
try container.operation();
```
