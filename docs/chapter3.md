# 第3章 内存和分配器 - Zig语言入门

在本章中，我们将讨论内存。Zig如何控制内存？使用了哪些常用工具？是否有任何重要的方面使Zig中的内存与众不同/特殊？你将在这里找到答案。

计算机从根本上依赖内存来运行。这个内存充当计算过程中生成的数据和值的临时存储空间。没有内存，编程语言中"变量"和"对象"的核心概念将是不可能的。

## 内存空间

你在Zig源代码中创建的每个对象都需要存储在某个地方，在你计算机的内存中。根据你定义对象的位置和方式，Zig将使用不同的"内存空间"，或不同类型的内存来存储这个对象。

每种类型的内存通常用于不同的目的。在Zig中，我们关心的内存有3种类型（或3种不同的内存空间）。它们是：

* 全局数据寄存器（或"全局数据段"）；
* 栈；
* 堆；

### 编译时已知与运行时已知

Zig用来决定将每个对象存储在哪里的一种策略是查看这个特定对象的值。更具体地说，通过调查这个值是在"编译时"还是在"运行时"已知。

当你在Zig中编写程序时，你在程序中编写的一些对象的值在**编译时是已知的**。这意味着，当你编译Zig源代码时，在编译过程中，`zig`编译器可以找出源代码中存在的特定对象的确切值。知道每个对象的长度（或大小）也很重要。因此，你在程序中编写的每个对象的长度（或大小）在某些情况下是**编译时已知的**。

`zig`编译器更关心知道特定对象的长度（或大小），而不是知道它的实际值。但是，如果`zig`编译器知道对象的值，那么，它会自动知道这个对象的大小。因为它可以通过查看值的大小来简单地计算对象的大小。

因此，`zig`编译器的优先级是发现源代码中每个对象的大小。如果所讨论的对象的值在编译时已知，那么，`zig`编译器会自动知道这个对象的大小/长度。但如果这个对象的值在编译时不已知，那么，这个对象的大小只有在且仅在这个对象的类型具有已知的固定大小时才在编译时已知。

为了使类型具有已知的固定大小，这个类型必须具有大小固定的数据成员。如果这个类型包含，例如，一个可变大小的数组，那么，这个类型没有已知的固定大小。因为这个数组在运行时可以有任何大小（即，它可以是2个元素的数组，或50个元素，或1千个元素等）。

例如，一个字符串对象，内部是一个常量u8值的数组（`[]const u8`），具有可变大小。它可以是包含100或500个字符的字符串对象。如果我们在编译时不知道这个字符串对象内将存储哪个确切的字符串，那么，我们无法在编译时计算这个字符串对象的大小。因此，任何类型，或你创建的任何结构体声明，如果包含没有明确固定大小的字符串数据成员，都会使这个类型，或你声明的这个新结构体，成为编译时没有已知固定大小的类型。

相反，如果你声明的这个结构体的类型包含一个数组数据成员，但这个数组有已知的固定大小，如`[60]u8`（声明一个60个`u8`值的数组），那么，这个类型，或你声明的这个结构体，就成为编译时具有已知固定大小的类型。因此，在这种情况下，`zig`编译器不需要在编译时知道这种类型的任何对象的确切值。因为编译器可以通过查看其类型的大小来找到存储这个对象所需的大小。

让我们看一个例子。在下面的源代码中，我们声明了两个常量对象（`name`和`array`）。因为这些特定对象的值写在源代码本身中（`"Pedro"`和从1到4的数字序列），`zig`编译器可以在编译过程中轻松发现这些常量对象（`name`和`array`）的值。这就是"编译时已知"的含义。它指的是你的Zig源代码中任何可以在编译时识别其值的对象。

```zig
fn input_length(input: []const u8) usize {
    const n = input.len;
    return n;
}

pub fn main() !void {
    const name = "Pedro";
    const array = [_]u8{1, 2, 3, 4};
    _ = name; _ = array;
}
```

光谱的另一端是值在编译时不已知的对象。函数参数是这方面的经典例子。因为每个函数参数的值取决于你调用函数时分配给这个特定参数的值。

例如，函数`input_length()`包含一个名为`input`的参数，它是一个常量`u8`整数的数组（`[]const u8`）。在编译时不可能知道这个特定参数的值。也不可能知道这个特定参数的大小/长度。因为它是一个没有在参数类型注释中明确指定固定大小的数组。

因此，我们知道这个`input`参数将是一个`u8`整数的数组。但我们在编译时不知道它的值，也不知道它的大小。这个信息只在运行时已知，即你的程序执行的时间段。因此，表达式`input.len`的值也只在运行时已知。这是任何函数的内在特征。**只需记住函数参数的值通常不是"编译时已知的"**。

然而，正如我之前提到的，对编译器真正重要的是在编译时知道对象的大小，而不一定是它的值。因此，尽管我们在编译时不知道对象`n`的值（它是表达式`input.len`的结果），但我们确实知道它的大小。因为表达式`input.len`总是返回类型`usize`的值，而类型`usize`具有已知的固定大小。

### 全局数据寄存器

全局数据寄存器是Zig程序可执行文件的特定部分，负责存储编译时已知的任何值。

你在源代码中声明的每个值在编译时已知的常量对象都存储在全局数据寄存器中。此外，你在源代码中编写的每个字面值，如字符串`"this is a string"`，或整数`10`，或布尔值如`true`，也都存储在全局数据寄存器中。

老实说，你不需要太关心这个内存空间。因为你无法控制它，你不能故意访问它或将其用于自己的目的。此外，这个内存空间不会影响你程序的逻辑。它只是存在于你的程序中。

### 栈vs堆

如果你熟悉系统编程，或者只是一般的低级编程，你可能听说过栈vs堆之间的"决斗"。这是两种不同类型的内存，或不同的内存空间，它们都在Zig中可用。

这两种类型的内存实际上并不相互决斗。这是初学者在看到"x vs y"风格的小报标题时常犯的错误。这两种类型的内存实际上是相互补充的。因此，在你编写的几乎每个Zig程序中，你可能会使用两者的组合。我将在接下来的部分详细描述每个内存空间。但现在，我只想确立这两种类型内存之间的主要区别。

本质上，栈内存通常用于存储长度固定且在编译时已知的值。相比之下，堆内存是一种**动态**类型的内存空间，这意味着，它用于存储长度可能在程序执行（运行时）期间增长的值（[Chen and Guo 2022](https://pedropark99.github.io/zig-book/Chapters/references.html#ref-jenny2022)）。

运行时增长的长度本质上与"运行时已知"类型的值相关联。换句话说，如果你有一个对象，其长度可能在运行时增长，那么，这个对象的长度在编译时变得不已知。如果长度在编译时不已知，这个对象的值也在编译时变得不已知。这些类型的对象应该存储在堆内存空间中，这是一个动态内存空间，可以增长或缩小以适应你的对象的大小。

### 栈

栈是一种使用**栈数据结构**力量的内存类型，因此得名。"栈"是一种_数据结构_，使用"后进先出"（LIFO）机制来存储你给它的值。我想你对这个数据结构很熟悉。但是，如果你不熟悉，[维基百科页面](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))或[Geeks For Geeks页面](https://www.geeksforgeeks.org/stack-data-structure/)都是完全理解这个数据结构如何工作的优秀且简单的资源。

因此，栈内存空间是一种使用栈数据结构存储值的内存类型。它通过遵循"后进先出"（LIFO）原则从内存中添加和删除值。

每次你在Zig中进行函数调用时，栈中都会为这个特定的函数调用保留一定量的空间（[Chen and Guo 2022](https://pedropark99.github.io/zig-book/Chapters/references.html#ref-jenny2022); [Zig Software Foundation 2024](https://pedropark99.github.io/zig-book/Chapters/references.html#ref-zigdocs)）。在这个函数调用中给函数的每个函数参数的值都存储在这个栈空间中。此外，你在函数作用域内声明的每个局部对象通常都存储在同一个栈空间中。

看看下面的例子，对象`result`是在`add()`函数作用域内声明的局部对象。因此，这个对象存储在为`add()`函数保留的栈空间中。`r`对象（在`add()`函数作用域之外声明）也存储在栈中。但由于它在"外部"作用域中声明，这个对象存储在属于这个外部作用域的栈空间中。

```zig
fn add(x: u8, y: u8) u8 {
    const result = x + y;
    return result;
}

pub fn main() !void {
    const r = add(5, 27);
    _ = r;
}
```

因此，你在函数作用域内声明的任何对象总是存储在栈内存中为该特定函数保留的空间中。这也适用于你在`main()`函数作用域内声明的任何对象。正如你所期望的，在这种情况下，它们存储在为`main()`函数保留的栈空间中。

关于栈内存的一个非常重要的细节是**它会自动释放自己**。这非常重要，记住这一点。当对象存储在栈内存中时，你没有释放/销毁这些对象的工作（或责任）。因为一旦栈空间在函数作用域结束时被释放，它们将自动被销毁。

因此，一旦函数调用返回（或结束，如果你更喜欢这样称呼它），栈中保留的空间被销毁，该空间中的所有对象都随之消失。这个机制存在是因为这个空间和其中的对象不再需要了，因为函数"完成了它的业务"。以我们上面展示的`add()`函数为例，这意味着对象`result`在函数返回后自动被销毁。

重要提示

存储在函数栈空间中的局部对象在函数作用域结束时自动释放/销毁。

这同样的逻辑适用于Zig中任何其他通过用花括号（`{}`）包围来拥有自己作用域的特殊结构。For循环、while循环、if else语句等。例如，如果你在for循环的作用域中声明任何局部对象，这个局部对象只能在这个特定for循环的作用域内访问。因为一旦这个for循环的作用域结束，为这个for循环保留的栈空间就被释放了。下面的例子演示了这个想法。

```zig
// 这无法成功编译！
const a = [_]u8{0, 1, 2, 3, 4};
for (0..a.len) |i| {
    const index = i;
    _ = index;
}
// 试图使用在for循环作用域中声明的对象，
// 而该对象已经不存在了。
std.debug.print("{d}\n", .{index});
```

这个机制的一个重要后果是，一旦函数返回，你就不能再访问为这个特定函数在栈中保留的空间内的任何内存地址。因为这个空间被销毁了。这意味着，如果这个局部对象存储在栈中，你不能编写一个**返回指向这个对象的指针**的函数。

想想看。如果栈中的所有局部对象在函数作用域结束时被销毁，你为什么还要考虑返回指向这些对象之一的指针？这个指针充其量是无效的，或者更可能是"未定义的"。

总之，编写一个返回局部对象本身作为结果的函数是完全可以的，因为这样，你返回该对象的值作为结果。但是，如果这个局部对象存储在栈中，你永远不应该编写一个返回指向这个局部对象的指针的函数。因为指针指向的内存地址不再存在。

因此，再次使用`add()`函数作为例子，如果你重写这个函数，使其返回指向局部对象`result`的指针，`zig`编译器实际上会编译你的程序，没有警告或错误。乍一看，这看起来像是按预期工作的好代码。但这是一个谎言！

如果你尝试查看`r`对象内的值，或者，如果你尝试在另一个表达式或函数调用中使用这个`r`对象，那么，你会有未定义的行为，以及程序中的主要错误（[Zig Software Foundation 2024](https://pedropark99.github.io/zig-book/Chapters/references.html#ref-zigdocs)，参见"生命周期和所有权"和"未定义行为"部分）。

```zig
fn add(x: u8, y: u8) *const u8 {
    const result = x + y;
    return &result;
}

pub fn main() !void {
    // 这段代码成功编译。但它有
    // 未定义的行为。永远不要这样做！！！
    // `r`对象是未定义的！
    const r = add(5, 27); _ = r;
}
```

这个"无效的栈变量指针"问题在许多编程语言社区中是众所周知的。如果你尝试在C或C++程序中做同样的事情（即返回存储在栈中的局部对象的地址），你也会在程序中得到未定义的行为。

重要提示

如果函数中的局部对象存储在栈中，你永远不应该从函数返回指向这个局部对象的指针。因为这个指针在函数返回后总是变得未定义，因为函数的栈空间在其作用域结束时被销毁。

但是，如果你真的需要在函数返回后以某种方式使用这个局部对象呢？你该怎么做？答案是："以你在C或C++程序中做的同样方式。通过返回存储在堆中的对象的地址"。堆内存具有更灵活的生命周期，并允许你获得指向已从其作用域返回的函数的局部对象的有效指针。

### 堆

栈的一个重要限制是，只有长度/大小在编译时已知的对象才能存储在其中。相比之下，堆是一种更动态（和灵活）的内存类型。它是用于大小/长度可能在程序执行期间增长的对象的完美内存类型。

几乎任何作为服务器的应用程序都是堆的经典用例。HTTP服务器、SSH服务器、DNS服务器、LSP服务器……任何类型的服务器。总之，服务器是一种运行很长时间的应用程序类型，它服务（或"处理"）到达这个特定服务器的任何传入请求。

堆是这种系统的好选择，主要是因为服务器不知道它在活动时将从用户那里接收多少请求。可能是单个请求、5千个请求，甚至零个请求。服务器需要能够根据它接收的请求数量分配和管理其内存。

栈和堆之间的另一个关键区别是，堆是你（程序员）完全控制的内存类型。这使堆成为更灵活的内存类型，但也使其更难使用。因为你（程序员）负责管理与之相关的一切。包括内存分配的位置、分配多少内存以及释放这个内存的位置。

> 与栈内存不同，堆内存由程序员明确分配，在明确释放之前不会被释放（[Chen and Guo 2022](https://pedropark99.github.io/zig-book/Chapters/references.html#ref-jenny2022)）。

要将对象存储在堆中，你（程序员）需要明确告诉Zig这样做，通过使用分配器在堆中分配一些空间。在[第3.3节](https://pedropark99.github.io/zig-book/Chapters/01-memory.html#sec-allocators)中，我将介绍如何使用分配器在Zig中分配内存。

重要提示

你在堆中分配的每个内存都需要由你（程序员）明确释放。

Zig中的大多数分配器确实在堆上分配内存。但这个规则的一些例外是`ArenaAllocator()`和`FixedBufferAllocator()`。`ArenaAllocator()`是一种特殊类型的分配器，它与第二种类型的分配器结合使用。另一方面，`FixedBufferAllocator()`是基于在栈上创建的缓冲区对象工作的分配器。这意味着`FixedBufferAllocator()`只在栈上进行分配。

### 总结

在讨论了所有这些无聊的细节之后，我们可以快速回顾一下我们学到的内容。总之，Zig编译器将使用以下规则来决定你声明的每个对象存储在哪里：

1. 每个字面值（如`"this is string"`、`10`或`true`）都存储在全局数据段中。
2. 每个值**在编译时已知**的常量对象（`const`）也存储在全局数据段中。
3. 每个长度/大小**在编译时已知**的对象（常量或非常量）都存储在当前作用域的栈空间中。
4. 如果使用分配器对象的`alloc()`或`create()`方法创建对象，这个对象存储在这个特定分配器对象使用的内存空间中。Zig中可用的大多数分配器使用堆内存，因此，这个对象很可能存储在堆中（`FixedBufferAllocator()`是一个例外）。
5. 堆只能通过分配器访问。如果你的对象不是通过分配器对象的`alloc()`或`create()`方法创建的，那么，它肯定不是存储在堆中的对象。

## 栈溢出

在栈上分配内存通常比在堆上分配更快。但这种更好的性能伴随着许多限制。我们已经在[第3.1.4节](https://pedropark99.github.io/zig-book/Chapters/01-memory.html#sec-stack)中讨论了栈的许多这些限制。但还有一个我想谈论的重要限制，即栈本身的大小。

栈的大小是有限的。这个大小因计算机而异，它取决于很多东西（计算机架构、操作系统等）。然而，这个大小通常不是很大。这就是为什么我们通常只使用栈来存储内存中的临时和小对象。

本质上，如果你尝试在栈上进行分配，而这个分配太大以至于超过了栈大小限制，就会发生**栈溢出**，你的程序因此崩溃。换句话说，当你尝试使用比栈上可用空间更多的空间时，就会发生栈溢出。

这种类型的问题与**缓冲区溢出**非常相似，即你试图使用比"缓冲区对象"中可用空间更多的空间。然而，栈溢出总是导致程序崩溃，而缓冲区溢出并不总是导致程序崩溃（尽管它经常这样做）。

你可以在下面的例子中看到栈溢出的例子。我们正在尝试在栈上分配一个非常大的`u64`值数组。你可以在下面看到这个程序没有成功运行，因为它因"分段错误"错误消息而崩溃。

```zig
var very_big_alloc: [1000 * 1000 * 24]u64 = undefined;
@memset(very_big_alloc[0..], 0);
```

`Segmentation fault (core dumped)`

这个分段错误是由在栈上进行的大内存分配引起的栈溢出的结果，用于存储`very_big_alloc`对象。这就是为什么非常大的对象通常存储在堆上，而不是栈上。

关于Zig的一个关键方面是，Zig中"没有隐藏的内存分配"。这真正意味着，"标准库中没有在你背后发生的分配"（[Sobeston 2024](https://pedropark99.github.io/zig-book/Chapters/references.html#ref-zigguide)）。

这是一个已知的问题，特别是在C++中。因为在C++中，有一些操作符在幕后分配内存，而你没有办法知道这一点，直到你实际阅读这些操作符的源代码，并找到内存分配调用。许多程序员发现这种行为令人烦恼且难以跟踪。

但是，在Zig中，如果标准库中的函数、操作符或任何东西在执行期间需要分配一些内存，那么，这个函数/操作符需要接收（作为输入）用户提供的分配器，才能真正分配它需要的内存。

这在"不"分配内存的函数和"实际上"分配内存的函数之间创建了明确的区别。只需查看这个函数的参数。如果一个函数或操作符有一个分配器对象作为其输入/参数之一，那么，你肯定知道这个函数/操作符将在执行期间分配一些内存。

一个例子是Zig标准库中的`allocPrint()`函数。使用这个函数，你可以使用格式说明符编写新字符串。因此，这个函数例如与C中的`sprintf()`函数非常相似。为了编写这样的新字符串，`allocPrint()`函数需要分配一些内存来存储输出字符串。

这就是为什么这个函数的第一个参数是你（用户/程序员）作为输入给函数的分配器对象。在下面的例子中，我使用`GeneralPurposeAllocator()`作为我的分配器对象。但我可以轻松使用Zig标准库中的任何其他类型的分配器对象。

```zig
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const allocator = gpa.allocator();
const name = "Pedro";
const output = try std.fmt.allocPrint(
    allocator,
    "Hello {s}!!!",
    .{name}
);
try stdout.print("{s}\n", .{output});
try stdout.flush();
```

`Hello Pedro!!!`

你对这个函数可以在哪里分配内存以及分配多少内存有很多控制。因为是你（用户/程序员）为函数提供要使用的分配器。这使得在Zig中更容易实现对内存管理的"完全控制"。

### 什么是分配器？

Zig中的分配器是你可以用来为程序分配内存的对象。它们类似于C中的内存分配函数，如`malloc()`和`calloc()`。因此，如果你在程序执行期间需要使用比最初拥有的更多内存，你可以简单地通过使用分配器对象请求更多内存。

Zig提供不同类型的分配器，它们通常通过标准库的`std.heap`模块可用。因此，只需将Zig标准库导入到你的Zig模块中（使用`@import("std")`），你就可以开始在代码中使用这些分配器。

此外，每个分配器对象都建立在Zig中的`Allocator`接口之上。这意味着，你在Zig中找到的每个分配器对象都必须有`alloc()`、`create()`、`free()`和`destroy()`方法。因此，你可以更改正在使用的分配器类型，但不需要更改为程序执行内存分配（和释放内存操作）的方法调用。

### 为什么你需要分配器？

正如我们在[第3.1.4节](https://pedropark99.github.io/zig-book/Chapters/01-memory.html#sec-stack)中描述的，每次你在Zig中进行函数调用时，栈中都会为这个函数调用保留一个空间。但栈有一个关键限制：存储在栈中的每个对象都有已知的固定长度。

但实际上，有两种非常常见的情况，栈的这种"固定长度限制"是一个交易破坏者：

1. 你在函数内创建的对象可能在函数执行期间增长大小。
2. 有时，不可能事先知道你将接收多少输入，或这个输入有多大。

此外，还有另一种情况，你可能想使用分配器，即当你想编写一个返回指向局部对象的指针的函数时。正如我在[第3.1.4节](https://pedropark99.github.io/zig-book/Chapters/01-memory.html#sec-stack)中描述的，如果这个局部对象存储在栈中，你不能这样做。然而，如果这个对象存储在堆中，那么，你可以在函数结束时返回指向这个对象的指针。因为你（程序员）控制你分配的任何堆内存的生命周期。你决定这个内存何时被销毁/释放。

这些是栈不好的常见情况。这就是为什么你需要不同的内存管理策略来在函数内存储这些对象。你需要使用可以与你的对象一起增长的内存类型，或者你可以控制这个内存的生命周期。堆符合这个描述。

在堆上分配内存通常被称为动态内存管理。当你创建的对象在程序执行期间增长大小时，你通过在堆中分配更多内存来增加你拥有的内存量以存储这些对象。在Zig中，你通过使用分配器对象来做到这一点。

### 不同类型的分配器

在撰写本书时，在Zig中，我们在标准库中有6种不同的分配器可用：

* `GeneralPurposeAllocator()`。
* `page_allocator()`。
* `FixedBufferAllocator()`和`ThreadSafeFixedBufferAllocator()`。
* `ArenaAllocator()`。
* `c_allocator()`（需要你链接到libc）。

每个分配器都有自己的优点和限制。除了`FixedBufferAllocator()`和`ArenaAllocator()`之外的所有分配器都是使用堆内存的分配器。因此，你使用这些分配器分配的任何内存都将放置在堆中。

### 通用分配器

`GeneralPurposeAllocator()`，顾名思义，是一个"通用"分配器。你可以将它用于每种类型的任务。在下面的例子中，我正在分配足够的空间来在对象`some_number`中存储单个整数。

```zig
const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    const some_number = try allocator.create(u32);
    defer allocator.destroy(some_number);

    some_number.* = @as(u32, 45);
}
```

虽然有用，但你可能想使用`c_allocator()`，它是C标准分配器`malloc()`的别名。所以，是的，如果你想，你可以在Zig中使用`malloc()`。只需使用Zig标准库中的`c_allocator()`。但是，如果你确实使用`c_allocator()`，你必须在使用`zig`编译器编译源代码时链接到Libc，通过在编译过程中包含标志`-lc`。如果你不将源代码链接到Libc，Zig将无法在你的系统中找到`malloc()`实现。

### 页分配器

`page_allocator()`是一个在堆中分配完整内存页的分配器。换句话说，每次你使用`page_allocator()`分配内存时，都会分配堆中的一整页内存，而不仅仅是其中的一小部分。

这个页的大小取决于你使用的系统。大多数系统在堆中使用4KB的页大小，所以，这通常是`page_allocator()`每次调用分配的内存量。这就是为什么`page_allocator()`在Zig中被认为是一个快速但也"浪费"的分配器。因为它在每次调用中分配大量内存，而你很可能不需要程序中那么多内存。

### 缓冲区分配器

`FixedBufferAllocator()`和`ThreadSafeFixedBufferAllocator()`是使用后端固定大小缓冲区对象的分配器对象。换句话说，它们使用固定大小的缓冲区对象作为内存的基础。当你要求这些分配器对象为你分配一些内存时，它们本质上是在这个固定大小的缓冲区对象内为你保留一些空间。

这意味着，为了使用这些分配器，你必须首先在代码中创建一个缓冲区对象，然后，将这个缓冲区对象作为输入给这些分配器。

这也意味着，这些分配器对象可以在栈或堆中分配内存。一切取决于你提供的缓冲区对象的位置。如果这个缓冲区对象位于栈中，那么，分配的内存是"基于栈的"。但如果它位于堆上，那么，分配的内存是"基于堆的"。

在下面的例子中，我正在栈上创建一个10个元素长的`buffer`对象。注意我将这个`buffer`对象给`FixedBufferAllocator()`构造函数。现在，因为这个`buffer`对象是10个元素长，这意味着我被限制在这个空间。我不能用这个分配器对象分配超过10个元素。如果我尝试分配超过这个数量，`alloc()`方法将返回`OutOfMemory`错误值。

```zig
var buffer: [10]u8 = undefined;
for (0..buffer.len) |i| {
    buffer[i] = 0; // 初始化为零
}

var fba = std.heap.FixedBufferAllocator.init(&buffer);
const allocator = fba.allocator();
const input = try allocator.alloc(u8, 5);
defer allocator.free(input);
```

记住，这些分配器对象分配的内存可以来自栈，也可以来自堆。这完全取决于你提供的缓冲区对象的位置。在上面的例子中，`buffer`对象位于栈中，因此，分配的内存基于栈。但如果它基于堆呢？

正如我们在[第3.2节](https://pedropark99.github.io/zig-book/Chapters/01-memory.html#sec-stack-overflow)中描述的，你使用堆而不是栈的主要原因之一是分配大量空间来存储非常大的对象。因此，假设你想使用一个非常大的缓冲区对象作为分配器对象的基础。你将不得不在堆上分配这个非常大的缓冲区对象。下面的例子演示了这种情况。

```zig
const heap = std.heap.page_allocator;
const memory_buffer = try heap.alloc(
    u8, 100 * 1024 * 1024 // 100 MB内存
);
defer heap.free(memory_buffer);
var fba = std.heap.FixedBufferAllocator.init(
    memory_buffer
);
const allocator = fba.allocator();

const input = try allocator.alloc(u8, 1000);
defer allocator.free(input);
```

### Arena分配器

`ArenaAllocator()`是一个分配器对象，它将子分配器作为输入。Zig中的`ArenaAllocator()`背后的想法类似于编程语言Go中"arenas"的概念。它是一个分配器对象，允许你随意分配内存多次，但只释放一次所有内存。换句话说，如果你例如调用了`ArenaAllocator()`对象的`alloc()`方法5次，你可以通过简单地调用同一`ArenaAllocator()`对象的`deinit()`方法一次释放在这5次调用中分配的所有内存。

如果你例如将`GeneralPurposeAllocator()`对象作为输入给`ArenaAllocator()`构造函数，如下面的例子中，那么，你使用`alloc()`执行的分配实际上将使用传递的底层对象`GeneralPurposeAllocator()`进行。因此，使用arena分配器，你请求的任何新内存都由子分配器分配。arena分配器真正做的唯一事情是帮助你用单个命令释放你多次分配的所有内存。在下面的例子中，我调用了`alloc()` 3次。因此，如果我不使用arena分配器，那么，我需要调用`free()` 3次来释放所有分配的内存。

```zig
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
var aa = std.heap.ArenaAllocator.init(gpa.allocator());
defer aa.deinit();
const allocator = aa.allocator();

const in1 = try allocator.alloc(u8, 5);
const in2 = try allocator.alloc(u8, 10);
const in3 = try allocator.alloc(u8, 15);
_ = in1; _ = in2; _ = in3;
```

### `alloc()`和`free()`方法

在下面的代码示例中，我们正在访问`stdin`，即标准输入通道，以接收用户的输入。我们使用`readSliceAll()`方法读取用户给出的输入。

现在，在读取用户的输入后，我们需要在程序中的某个地方存储这个输入。这就是为什么我在这个例子中使用分配器。我使用它来分配一些内存量来存储用户给出的这个输入。更具体地说，分配器对象的`alloc()`方法用于分配能够存储50个`u8`值的数组。

注意这个`alloc()`方法接收两个输入。第一个是类型。这定义了分配的数组将存储什么类型的值。在下面的例子中，我们正在分配一个无符号8位整数（`u8`）的数组。但你可以创建一个数组来存储你想要的任何类型的值。接下来，在第二个参数中，我们通过指定这个数组将包含多少元素来定义分配的数组的大小。在下面的情况下，我们正在分配一个50个元素的数组。

在[第1.8节](https://pedropark99.github.io/zig-book/Chapters/01-zig-weird.html#sec-zig-strings)中，我们描述了Zig中的字符串只是字符数组。每个字符由一个`u8`值表示。因此，这意味着在对象`input`中分配的数组能够存储50个字符长的字符串。

因此，本质上，表达式`var input: [50]u8 = undefined`将在当前作用域的栈中创建一个50个`u8`值的数组。但是，你可以使用表达式`var input = try allocator.alloc(u8, 50)`在堆中分配相同的数组。

```zig
const std = @import("std");
var stdin_buffer: [1024]u8 = undefined;
var stdin_reader = std.fs.File.stdin().reader(&stdin_buffer);
const stdin = &stdin_reader.interface;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var input = try allocator.alloc(u8, 50);
    defer allocator.free(input);
    @memset(input[0..], 0);

    // 读取用户输入
    stdin.readSliceAll(input[0..]) catch |err| switch(err) {
        // 到达输入末尾，不做其他事情
        error.EndOfStream => {},
        // 如果是其他类型的错误，则返回它
        else => return err,
    };
    std.debug.print("{s}\n", .{input});
}
```

另外，请注意，在这个例子中，我们使用`defer`关键字（我在[第2.1.3节](https://pedropark99.github.io/zig-book/Chapters/03-structs.html#sec-defer)中描述过）在当前作用域结束时运行一小段代码，即表达式`allocator.free(input)`。当你执行这个表达式时，分配器将释放它为`input`对象分配的内存。

我们在[第3.1.5节](https://pedropark99.github.io/zig-book/Chapters/01-memory.html#sec-heap)中讨论过这个。你**应该始终**明确释放使用分配器分配的任何内存！你可以通过使用你用于分配这个内存的同一分配器对象的`free()`方法来做到这一点。在这个例子中，`defer`关键字仅用于帮助我们在当前作用域结束时执行这个释放操作。

### `create()`和`destroy()`方法

使用`alloc()`和`free()`方法，你可以一次分配内存来存储多个元素。换句话说，使用这些方法，我们总是分配一个数组来一次存储多个元素。但是，如果你只需要足够的空间来存储单个项目呢？你应该通过`alloc()`分配单个元素的数组吗？

答案是否定的！在这种情况下，你应该使用分配器对象的`create()`方法。每个分配器对象都提供`create()`和`destroy()`方法，它们分别用于为单个项目分配和释放内存。

因此，本质上，如果你想分配内存来存储元素数组，你应该使用`alloc()`和`free()`。但如果你只需要存储单个项目，那么，`create()`和`destroy()`方法是理想的。

在下面的例子中，我定义了一个结构体来表示某种用户。它可能是游戏的用户，或管理资源的软件，这并不重要。注意这次我使用`create()`方法在程序中存储单个`User`对象。还要注意，我使用`destroy()`方法在作用域结束时释放这个对象使用的内存。

```zig
const std = @import("std");
const User = struct {
    id: usize,
    name: []const u8,

    pub fn init(id: usize, name: []const u8) User {
        return .{ .id = id, .name = name };
    }
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    const user = try allocator.create(User);
    defer allocator.destroy(user);

    user.* = User.init(0, "Pedro");
}
```

---

脚注翻译：

1. [https://en.wikipedia.org/wiki/Stack_(abstract_data_type)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))
2. [https://www.geeksforgeeks.org/stack-data-structure/](https://www.geeksforgeeks.org/stack-data-structure/)
3. [https://ziglang.org/documentation/master/#Lifetime-and-Ownership](https://ziglang.org/documentation/master/#Lifetime-and-Ownership)
4. [https://ziglang.org/documentation/master/#Undefined-Behavior](https://ziglang.org/documentation/master/#Undefined-Behavior)
5. [https://go.dev/src/arena/arena.go](https://go.dev/src/arena/arena.go)
6. 只需记住这是一个过度简化。如果我们只谈论ASCII字符串，那么是的，每个`u8`值代表字符串中的一个单独字符。但如果我们进入UTF-8编码字符串的领域，那么，这种情况并不总是正确的。
