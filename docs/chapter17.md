# 第17章 向量和SIMD介绍 - Zig入门

在本章中，我想讨论Zig中的向量（vectors），它们与SIMD操作相关（注意：它们与C++中的`std::vector`类没有任何关系）。

## 什么是SIMD？

SIMD（_单指令流多数据流，Single Instruction/Multiple Data_）是一组广泛应用于视频/音频编辑程序以及图形应用程序中的操作。SIMD并不是新技术，但在普通桌面计算机上大规模使用SIMD是相对较新的。在过去，SIMD仅用于"超级计算机模型"。

如今，大多数现代CPU型号（来自AMD、Intel等）无论是桌面型号还是笔记本型号，都支持SIMD操作。因此，如果你的计算机中安装的是非常老旧的CPU型号，那么你的计算机可能不支持SIMD操作。

为什么人们开始在软件中使用SIMD？答案是性能。但SIMD究竟是如何实现更好的性能的呢？本质上，SIMD操作是在程序中实现并行计算的一种不同策略，从而使计算更快。

SIMD背后的基本思想是让单个指令同时对多个数据进行操作。当你执行普通的标量操作时，例如四个加法指令，每个加法都是分别执行的，一个接一个。但使用SIMD时，这四个加法指令被转换为单个指令，因此，四个加法会并行地、同时执行。

目前，`zig`编译器允许你在向量对象上应用以下一组运算符。当你在向量对象上应用这些运算符时，会使用SIMD进行计算，因此，这些运算符默认按元素并行应用。

* 算术运算（`+`、`-`、`/`、`*`、`@divFloor()`、`@sqrt()`、`@ceil()`、`@log()`等）
* 位运算符（`>>`、`<<`、`&`、`|`、`~`等）
* 比较运算符（`<`、`>`、`==`等）

SIMD操作通常通过_SIMD内置函数_执行，这只是执行SIMD操作的函数的一个花哨名称。这些SIMD内置函数（或"SIMD函数"）总是对一种特殊类型的对象进行操作，这种对象被称为"向量"。因此，为了使用SIMD，你必须创建一个"向量对象"。

向量对象通常是一个固定大小的128位（16字节）块。因此，你在实际中遇到的大多数向量本质上是包含2个8字节值，或4个4字节值，或8个2字节值等的数组。然而，不同的CPU型号可能有不同的SIMD扩展（或"实现"），这些扩展可能提供更大尺寸（256位或512位）的向量对象类型，以便在单个向量对象中容纳更多数据。

你可以在Zig中使用`@Vector()`内置函数创建新的向量对象。在这个函数内部，你需要指定向量长度（向量中元素的数量）和向量元素的数据类型。这些向量对象只支持原始数据类型。在下面的例子中，我创建了两个向量对象（`v1`和`v2`），每个都包含4个`u32`类型的元素。

还要注意，在下面的例子中，第三个向量对象（`v3`）是通过前两个向量对象（`v1`加`v2`）的和创建的。因此，向量对象上的数学运算默认按元素进行，因为同一操作（在本例中是加法）被转换为单个指令，该指令在向量的所有元素上并行复制执行。

```zig
const v1 = @Vector(4, u32){4, 12, 37, 9};
const v2 = @Vector(4, u32){10, 22, 5, 12};
const v3 = v1 + v2;
try stdout.print("{any}\n", .{v3});
try stdout.flush();
```

输出：`{ 14, 34, 42, 21 }`

这就是SIMD如何为你的程序带来更高性能的方式。我们不是使用for循环遍历`v1`和`v2`的元素，一次一个元素地将它们相加，而是享受SIMD的好处，它同时并行执行所有4个加法运算。

因此，`@Vector`结构本质上是SIMD向量对象的Zig表示。这些向量对象中的元素将并行操作，当且仅当你当前的CPU型号支持SIMD操作时。如果你的CPU型号不支持SIMD，那么`@Vector`结构可能会产生与"for循环解决方案"类似的性能。

### 将数组转换为向量

有多种方法可以将普通数组转换为向量对象。你可以使用隐式转换（直接将数组赋值给向量对象），或者使用切片从普通数组创建向量对象。

在下面的例子中，我们隐式地将数组`a1`转换为长度为4的向量对象（`v1`）。我们首先显式注释向量对象的数据类型，然后将数组对象赋值给这个向量对象。

还要注意，在下面的例子中，通过获取数组对象（`a1`）的切片，然后将指向该切片的指针（`.*`）存储到第二个向量对象中，创建了第二个向量对象（`v2`）。

```zig
const a1 = [4]u32{4, 12, 37, 9};
const v1: @Vector(4, u32) = a1;
const v2: @Vector(2, u32) = a1[1..3].*;
_ = v1; _ = v2;
```

值得强调的是，只有大小在编译时已知的数组和切片才能转换为向量。向量通常是仅适用于编译时已知大小的结构。因此，如果你有一个大小在运行时才知道的数组，那么你首先需要将其复制到一个编译时已知大小的数组中，然后再将其转换为向量。

### `@splat()`函数

你可以使用`@splat()`内置函数创建一个在所有元素中填充相同值的向量对象。这个函数的创建是为了提供一种快速简便的方法，直接将标量值（也就是单个值，如单个字符或单个整数等）转换为向量对象。

因此，我们可以使用`@splat()`将单个值（如整数`16`）转换为长度为1的向量对象。但我们也可以使用这个函数将同一个整数`16`转换为长度为10的向量对象，该向量对象填充了10个`16`值。下面的例子展示了这个想法。

```zig
const v1: @Vector(10, u32) = @splat(16);
try stdout.print("{any}\n", .{v1});
try stdout.flush();
```

输出：`{ 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 }`

### 注意过大的向量

正如我在[第17.2节](https://pedropark99.github.io/zig-book/Chapters/15-vectors.html#sec-what-vectors)中描述的，每个向量对象通常是128、256或512位的小块。这意味着向量对象通常很小，当你试图反其道而行之，创建一个非常大的向量对象（即，大小接近兆字节级别）时，你通常会遇到崩溃和编译器的错误提示。

例如，如果你尝试编译下面的程序，你很可能会在构建过程中遇到段错误或LLVM错误。请注意不要创建过大的向量对象。

```zig
const v1: @Vector(1000000, u32) = @splat(16);
_ = v1;
```

输出：`Segmentation fault (core dumped)`（段错误（核心已转储））
